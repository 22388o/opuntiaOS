#pragma GCC system_header

#ifndef _LIBCXX_VECTOR
#define _LIBCXX_VECTOR

#include <__config>
#include <memory>
#include <utility>

_LIBCXX_BEGIN_NAMESPACE_STD

template <class T, class Allocator = std::allocator<T>>
class vector {
public:
    typedef T* iterator;

    vector()
    {
        grow(m_capacity);
    }

    explicit vector(int capacity)
    {
        grow(capacity);
    }

    vector(const vector& v)
    {
        grow(v.m_capacity);
        m_size = v.m_size;
        copy(m_data, v.m_data, m_size);
    }

    vector(vector&& v)
    {
        m_size = v.m_size;
        m_capacity = v.m_capacity;
        m_data = v.m_data;
        v.m_size = v.m_capacity = 0;
        v.m_data = nullptr;
    }

    ~vector()
    {
        clear();
    }

    vector& operator=(const vector& v)
    {
        grow(v.m_capacity);
        m_size = v.m_size;
        copy(m_data, v.m_data, m_size);
        return *this;
    }

    vector& operator=(vector&& v)
    {
        if (this != &v) {
            clear();
            m_size = v.m_size;
            m_capacity = v.m_capacity;
            m_data = v.m_data;
            v.m_size = 0;
            v.m_capacity = 0;
            v.m_data = nullptr;
        }
        return *this;
    }

    inline void push_back(T&& el)
    {
        ensure_capacity(size() + 1);
        new (end()) T(std::move(el));
        m_size++;
    }

    inline void push_back(const T& el)
    {
        push_back(T(el));
    }

    inline const T& at(size_t i) const
    {
        return data()[i];
    }

    inline T& at(size_t i)
    {
        return data()[i];
    }

    void clear()
    {
        clear_remain_capacity();
        if (m_data) {
            free(m_data);
            m_data = nullptr;
        }
    }

    void clear_remain_capacity()
    {
        if (m_data) {
            for (size_t i = 0; i < m_size; ++i) {
                destroy_at(&m_data[i]);
            }
        }
        m_size = 0;
    }

    inline void resize(size_t new_size)
    {
        ensure_capacity(new_size);
        m_size = new_size;
    }

    inline size_t size() const { return m_size; }
    inline size_t capacity() const { return m_capacity; }

    inline const T& operator[](size_t i) const { return at(i); }
    inline T& operator[](size_t i) { return at(i); }
    inline const T& front() const { return at(0); }
    inline T& front() { return at(0); }
    inline const T& back() const { return at(size() - 1); }
    inline T& back() { return at(size() - 1); }
    inline T* data() { return m_data; }
    inline const T* data() const { return m_data; }

    inline T* end() { return m_data + m_size; }

private:
    inline void ensure_capacity(size_t new_size)
    {
        int capacity = 16;
        while (new_size > capacity) {
            capacity *= 2;
        }
        grow(capacity);
    }

    void grow(size_t capacity)
    {
        if (!m_data) {
            m_data = m_allocator.allocate(capacity);
        } else {
        retry:
            auto new_buf = m_allocator.allocate(capacity);
            if (!new_buf) {
                goto retry;
            }

            for (size_t i = 0; i < m_size; i++) {
                construct_at(&new_buf[i], std::move(at(i)));
                destroy_at(&m_data[i]);
            }
            m_allocator.deallocate(m_data, m_capacity);
            m_data = new_buf;
        }
        m_capacity = capacity;
    }

    void copy(T* to, T* from, size_t len)
    {
        for (size_t i = 0; i < len; i++) {
            new (to) T(*from);
            to++;
            from++;
        }
    }

    size_t m_size { 0 };
    size_t m_capacity { 16 };
    T* m_data { nullptr };
    Allocator m_allocator;
};

_LIBCXX_END_NAMESPACE_STD

#endif // _LIBCXX_VECTOR